# NextChord Development Guide for Windsurf & AI

This guide helps you feed tasks to Windsurf or ChatGPT in a structured way.

## How to Use This Guide

1. Pick a phase (start with Phase 1).
2. Choose a task from that phase.
3. Copy the **"Windsurf Prompt"** section.
4. Paste it into Windsurf with optional context (e.g., "I already have models defined here...").
5. Let Windsurf generate the code.
6. Review, ask questions, iterate.

---

## Phase 1: Core Library & Basic UI

**Goal**: Build a functional songbook with library view, editor, and viewer. No MIDI or audio yet.

### Task 1.1: Set Up Drift Database

**What This Does**: Creates a local SQLite database to store songs and setlists. Uses Drift ORM (no raw SQL).

**Files to Create**:
- `lib/data/database/app_database.dart` (database definition)
- `lib/data/models/song_model.dart` (auto-generated by Drift)
- `lib/data/models/setlist_model.dart` (auto-generated by Drift)

**Windsurf Prompt**:

```
I'm building a Flutter music app called NextChord. I need to set up a Drift database.

Context:
- I have domain entities defined in lib/domain/entities/song.dart
- The Song entity has: id, title, artist, body (ChordPro text), key, capo, bpm, timeSignature, tags, audioFilePath, notes, createdAt, updatedAt
- The Setlist entity has: id, name, items (list of SetlistItems), notes, createdAt, updatedAt
- I'm using Drift ORM for database management

Please create:
1. lib/data/database/app_database.dart - A Drift database with:
   - A "songs" table with all Song fields
   - A "setlists" table with all Setlist fields
   - Proper data types and null handling
   - Generated DAOs (data access objects) for querying

2. lib/data/database/app_database.g.dart - Auto-generated part file (you'll explain how to generate this with build_runner)

Include:
- Proper column definitions with types
- DateTime fields stored as integers (epoch milliseconds)
- A JSON column for "tags" (stored as TEXT in SQLite)
- Comments explaining each table and field

After this, I'll run: flutter pub run build_runner build
```

### Task 1.2: Create Song Repository

**What This Does**: CRUD operations for songs. Abstracts database away from UI code.

**Files to Create**:
- `lib/data/repositories/song_repository.dart`

**Windsurf Prompt**:

```
I have a Drift database set up with songs and setlists tables (see lib/data/database/app_database.dart).

Please create lib/data/repositories/song_repository.dart with a SongRepository class that has these methods:

1. Future<List<Song>> getAllSongs() - Fetch all songs
2. Future<Song?> getSongById(String id) - Fetch one song
3. Future<List<Song>> searchSongs(String query) - Search by title or artist
4. Future<void> insertSong(Song song) - Add a new song
5. Future<void> updateSong(Song song) - Update a song
6. Future<void> deleteSong(String id) - Delete a song
7. Future<List<Song>> getSongsByTag(String tag) - Filter by tag
8. Future<List<Song>> getSongsByKey(String key) - Filter by key

The repository should:
- Use the AppDatabase and generated DAO
- Map between domain Song entity and database models
- Handle errors gracefully
- Include helpful comments

The domain Song is in lib/domain/entities/song.dart.
The database is in lib/data/database/app_database.dart.
```

### Task 1.3: Build Library Screen

**What This Does**: Shows a list of all songs with search and filter. First UI screen users see.

**Files to Create**:
- `lib/presentation/screens/library_screen.dart`
- `lib/presentation/widgets/song_list_tile.dart`
- `lib/presentation/providers/song_provider.dart`

**Windsurf Prompt**:

```
I'm building a Flutter music app. I need a Library screen that displays all songs from my database.

Context:
- I have SongRepository in lib/data/repositories/song_repository.dart
- Domain Song entity is in lib/domain/entities/song.dart
- I'm using Provider for state management

Please create:

1. lib/presentation/providers/song_provider.dart - A notifier that:
   - Holds a list of songs
   - Has a method to load all songs from the repository
   - Has a method to search songs by title/artist
   - Handles loading and error states
   - Uses ChangeNotifier (from Provider package)

2. lib/presentation/widgets/song_list_tile.dart - A ListTile widget that displays:
   - Song title
   - Artist name
   - Key and Capo info
   - Tags as small chips
   - Tap to select/edit

3. lib/presentation/screens/library_screen.dart - Main screen that:
   - Shows a searchable list of all songs
   - Has a search/filter bar at the top
   - Uses the SongProvider to load and filter data
   - Has a FAB (floating action button) to add a new song
   - Shows "No songs" message if empty
   - Shows loading spinner while fetching data

Include proper error handling and use Material 3 design.
```

### Task 1.4: Build Song Editor Screen

**What This Does**: Lets users create and edit songs with ChordPro text and metadata.

**Files to Create**:
- `lib/presentation/screens/song_editor_screen.dart`

**Windsurf Prompt**:

```
I'm building a song editor for my Flutter music app.

Context:
- Domain Song entity is in lib/domain/entities/song.dart with fields: title, artist, body (ChordPro text), key, capo, bpm, timeSignature, tags
- SongRepository is in lib/data/repositories/song_repository.dart
- I'm using Provider for state management

Please create lib/presentation/screens/song_editor_screen.dart with:

1. A form with fields for:
   - Title (TextFormField)
   - Artist (TextFormField)
   - Key (Dropdown: C, C#, D, D#, E, F, F#, G, G#, A, A#, B)
   - Capo (Spinner: 0-12)
   - BPM (TextFormField, numeric)
   - Time Signature (Dropdown: 4/4, 3/4, 6/8)
   - Tags (Editable list of chips)
   - Body (MultilineTextField for ChordPro text - the main lyrics/chords)
   - Audio file path (Button to pick file)

2. Save button that:
   - Validates all required fields
   - Creates/updates a Song object
   - Calls SongRepository to save
   - Shows success/error messages
   - Navigates back to library

3. If editing an existing song:
   - Pre-populate all fields
   - Show "Edit" instead of "Create"

Use form validation, proper error handling, and Material 3 design.
```

### Task 1.5: Build Song Viewer Screen

**What This Does**: Displays a song in a nice, readable format for performing. Shows chords and lyrics.

**Files to Create**:
- `lib/presentation/screens/song_viewer_screen.dart`
- `lib/presentation/widgets/chord_renderer.dart`

**Windsurf Prompt**:

```
I'm building a song viewer screen for live performance. This is where musicians read chords and lyrics.

Context:
- Song entity in lib/domain/entities/song.dart (has body with ChordPro text)
- ChordProParser utility in lib/core/utils/chordpro_parser.dart
- Domain Song with fields: title, artist, key, capo, body, bpm

Please create:

1. lib/presentation/widgets/chord_renderer.dart - A widget that:
   - Takes ChordPro text as input (e.g., "[Cmaj7] This is the [F] chorus")
   - Renders it with chords highlighted (different color, maybe bold)
   - Supports adjustable font size
   - Highlights [chords] in one color, lyrics in another

2. lib/presentation/screens/song_viewer_screen.dart - Full screen that:
   - Shows the song title and artist at top
   - Displays the full lyrics/chords using the chord_renderer widget
   - Has controls:
     * Font size slider (small â†’ large)
     * Light/Dark theme toggle (for stage use)
     * Display current Key and Capo
   - Scrollable body (for long songs)
   - Back button to return to library
   - (Future: auto-scroll controls)

Include:
   - Nice typography for stage visibility
   - Color contrast suitable for outdoor/stage lighting
   - Landscape mode support
```

---

## Phase 2: ChordPro & Transpose

### Task 2.1: Enhance ChordPro Parser

**Windsurf Prompt**:

```
I have a basic ChordPro parser in lib/core/utils/chordpro_parser.dart.

Please enhance it to:
1. Extract section headers: {soh: Intro}, {verse: Verse 1}, {chorus}, etc.
2. Extract metadata: {title: ...}, {artist: ...}, {key: ...}, {capo: ...}
3. Handle comments: # This is a comment
4. Parse structured chords: [Cmaj7], [Am/G], [Dm7b5]
5. Transpose complex chords correctly (preserve modifiers like "maj7", "b5", etc.)
6. Add a function to render ChordPro as structured data:
   - Returns a list of "lines" where each line has chords and lyrics

Include comprehensive comments so I understand how it works.
```

### Task 2.2: Add Transpose to Song Viewer

**Windsurf Prompt**:

```
I have a song viewer screen (lib/presentation/screens/song_viewer_screen.dart).

We also have buttons added in the viewer for Capo and Transpose. I want you to:
1. Enable the transposition feature for the viewer:
   - Make a flyout menu with an identical look and feel to the Settings button in the Viewer with + and - buttons to transpose up/down by semitones
   - Display current transposition (e.g., "Transposed +3 semitones")
   - Apply transposition to displayed chords without modifying the song
   - Display current transposition (e.g., "Transposed +3 semitones")
   - Apply transposition to displayed chords without modifying the song   
   - Add any metadata required to enable transpose options to only apply to a set list if desired, but not to the base song itself

2. Enable the capo feature for the viewer:
   - Make a flyout menu with an identical look and feel to the Settings button in the Viewer with + and - buttons to incrementally increase the number of fret the capo is installed on
   - Show "Capo: 3" (from song data)
   - Option to adjust capo from the UI
   - Recalculate displayed chords when capo changes
   - Add any metadata required to enable capo options to only apply to a set list if desired, but not to the base song itself



Example: Song is in key C with capo 0. User transposes +2 semitones â†’ display chords as if in key D.
Or: Song is in key G with capo 2. User moves capo to 5 â†’ adjust displayed chords accordingly.

Keep the original song data unchanged. Only the display changes.
```

---

## Phase 3: MIDI Integration

### Task 3.1: Initialize MIDI Service

**Windsurf Prompt**:

```
I'm integrating MIDI support using flutter_midi_command package.

Please create lib/services/midi/midi_service.dart with a MidiService class that:

1. Initializes the MIDI system on app startup
2. Scans and lists available MIDI devices (inputs and outputs)
3. Connects to a selected MIDI device
4. Sends Program Change (PC) messages: sendProgramChange(int program)
5. Sends Control Change (CC) messages: sendControlChange(int controller, int value)
6. Handles connection state (connected, disconnected, error)
7. Includes error handling and logging

Make it a singleton so it can be accessed from anywhere in the app.

Make the Settings menu in the global sidebar active with the same look and feel as Songs and Setlists. i.e. when it is clicked, it should expand, and in that Settings submenu I would like a MIDI Options button. Any settings related to MIDI will go there

Include comments explaining:
- What Program Change does (selects a preset/patch)
- What Control Change does (adjusts a parameter)
- MIDI value ranges (0-127 for most values)
```

### Task 3.2: Build MIDI Settings Screen

**Windsurf Prompt**:

```
I have a MidiService (lib/services/midi/midi_service.dart) and domain MidiMapping entity (lib/domain/entities/song.dart).

Please create:

1. lib/presentation/screens/midi_settings_screen.dart with:
   - List of available MIDI devices (inputs/outputs)
   - Select which device to use
   - Test buttons to send sample PC/CC messages
   - Show connection status

2. lib/presentation/screens/midi_mapping_editor.dart - Edit MIDI mappings for a song:
   - Input fields for Program Change number (0-127)
   - List of Control Changes with controller and value
   - Add/remove CC entries
   - Save mapping to database
```

### Task 3.3: Link Song Selection to MIDI

**Windsurf Prompt**:

```
I have:
- Song editor screen (lib/presentation/screens/song_editor_screen.dart)
- MIDI service (lib/services/midi/midi_service.dart)
- MIDI mappings in database

Please modify the song editor to:
1. Load the MIDI mapping for the current song
2. In the left half of the row with Tags, Add a "MIDI Sends" area:
   - Create a similar data entry style to the Tags section (default text saying "No sends" and an Edit button)
   - Using the same style as the Edit Tags modal, create a midi_sends_modal.dart with the same text entry box and general design
   - Apply any necessary framework to the modal that will enable tab-to-complete and enter-to-save functionality like the Edit Tags in the future
3. Handle errors gracefully (show toast if no device connected)
```

---

## Phase 4: Audio & Polish

### Task 4.1: Audio Playback Service

**Windsurf Prompt**:

```
I need audio playback for backing tracks using just_audio package.

Create lib/services/audio/audio_service.dart with:
1. Load and play audio files (MP3, WAV)
2. Play, pause, stop controls
3. Seek to position
4. Volume control
5. Playback state stream (playing, paused, stopped)
6. Handle errors

Make it a singleton that persists across screens.
```

### Task 4.2: Setlist Management

**Windsurf Prompt**:

```
I need a setlist management feature.

Please create:
1. lib/presentation/screens/setlist_screen.dart - Shows all setlists
2. lib/presentation/screens/setlist_editor_screen.dart - Edit a setlist:
   - Drag-and-drop to reorder songs
   - Add/remove songs
   - Add dividers/section labels
   - Save to database
3. Update lib/data/repositories/ to include SetlistRepository with CRUD operations
```

---

## Template: Generic Windsurf Prompt

Use this template for any task not listed above:

```
I'm building a Flutter app called NextChord (a chord book + MIDI controller for musicians).

Current context:
- I have [describe what you already have]
- I need [describe what you want]
- Related files: [list relevant files]
- Requirements:
  * [requirement 1]
  * [requirement 2]
  * [requirement 3]

Please create/modify [file path] to:
- [specific task 1]
- [specific task 2]
- [include error handling / validation / etc.]

Use [Flutter/Dart best practices / Material 3 design / etc.].
```

Current Context:
- I have the song viewer with an Autoscroll button
- I have a standard way of making flyout menus for these buttons in the Viewer, as can be referenced from the Settings and Capo buttons
- I need an Autoscroll provider created that will calculate the rate at which to scroll the Viewer screen in order to reach the end of the song at the end of the Duration as configured in the song metadata. If no duration is specified, use 3:00 as the default duration.
- I need the provider to be able to be started and stopped. Pressing the Autoscroll button should change the button to a blue background to indicate it is "on". Clicking the button again will pause the autoscrolling and leave the viewer window as-is. If autoscroll is restarted, it will continue scrolling from the present position.
- I need the provider to be able to have the duration adjusted up or down while it is autoscrolling. To facilitate this, we need a flyout menu with + and - buttons to incrementally increase or decrease the duration by 15 seconds each time. This needs to stay concise to fit the flyout menu format. Format it like "<- <mm:ss> +>". The flyout menu should stay open until Autoscroll is stopped.
- I need the user to be able to swipe up/down on the Viewer screen to override the current position if needed. After a couple of seconds, Autoscroll can continue from wherever the user left the Viewer window scrolled to at the same rate that was calculated based on the duration. 



---

## Running & Testing

### First Time Setup

```bash
# Navigate to the project
cd NextChord

# Get dependencies
flutter pub get

# Generate code (for Drift, JSON serializable, etc.)
flutter pub run build_runner build

# Run the app
flutter run
```

### During Development

```bash
# Run with hot reload (great for UI tweaking)
flutter run -v

# Run on specific device
flutter run -d <device_id>

# List available devices
flutter devices

# Run tests
flutter test
```

### Common Issues

**"flutter_midi_command not available on iOS/Android"**
â†’ You might need to enable entitlements in Xcode (macOS) or manifest in Android Studio. Windsurf can help with platform-specific setup.

**"Build runner not generating code"**
â†’ Run `flutter pub run build_runner clean` then `build_runner build` again.

**"Hot reload not reflecting changes"**
â†’ Sometimes you need a full rebuild: `flutter run --no-fast-start`

---

## Tips for Success

1. **Build incrementally**. Complete one task fully before moving to the next.
2. **Test as you go**. Don't wait until Phase 4 to check if things work.
3. **Ask Windsurf for explanations**. "Explain how the Provider pattern works in this code" is a great question.
4. **Read generated code**. Drift auto-generates codeâ€”understanding it helps.
5. **Use the debugger**. Flutter DevTools is powerful.

Good luck! ðŸŽ¸
